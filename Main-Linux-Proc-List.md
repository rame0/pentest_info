# kthreadd
PID 2, так называемый “мастер потоков” - это мастер-процесс, создающий процессы для управления аппаратной составляющей. В целом, большинство процессов ниже являются порождениями этого процесса, он как главный босс, раздающий работу и кричащий, что делать.

# rcu_gp
Read-copy update. Специальный механизм синхронизации данных, позволяющий обрабатывать данные в несколько потоков. Нужен для многопоточной работы с данными.

# kworker/(u)X:X(H)
Процессы которые помогают ядру обрабатывать запросы. Таких процессов может быть много (в зависимости от нагрузки на ядро, чем больше запросов на выделение прерывания, чем больше таймеров и системных вызовов, тем больше процессов по работе в пространстве ядра).

# mm_percpu_wq
Процесс для управления памятью для каждого ядра.

# ksoftirqd/0
На каждое процессорное ядро ядром Linux порождается один такой процесс, который необходим как для обработки аппаратных прерываний от установленного оборудования, прерываний от установленного программного обеспечения так и обработки исключений возникающих в процессе работы операционной системы. Посмотреть статистику можно в файле /proc/interrupts

# rcu_sched
Дополнительный процесс для корректной работы RCU (это процесс-планировщик).

# rcu_bh
Дополнительный процесс для корректной работы RCU, родственный rcu_sched, отвечает за так называемые “грейс периоды”, они же интервалы времени для завершения RCU-заданий (если простыми словами).

# migration/0
Процесс, которые распределяет другие процессы по ядрам. Один процесс на одно ядро.

# cpuhp/0
Процесс, создающийся 1 на 1 ядро, отвечающий за физическое добавление/удаление CPU в/из систем.

# kdevtmpfs
Заполняет и обслуживает дерево устройств.

# netns
Управляет сетью (фактически оно управляет пространством имен для сетей)

# khungtaskd
Процесс, который каждые две (чаще всего) минуты ищет зависшие задания.

# oom_reaper
Процесс, отвечающий за “убийство” процесса, который потребляет больше всего памяти, если ОЗУ на компьютере заканчивается.

# writeback
Процесс который записывает отложенные в кэше контроллера накопителя данные на сам накопитель. Инициировать можно командой sync

# kcompactd0
Отвечает за так называемое уплотнение памяти (работает по 1 процессу на 1 ядро, обычно - каждые 15 секунд).

# khugepaged
Отслеживает эффективность использование “huge pages” виртуальной памяти.

# crypto
Предоставляет API к крипто-модулю ядра.

# kintegrityd
Проверяет целостность блочных устройств с помощью записи/чтения с/на этих устройств/ах.

# kblockd
Процесс ищет перегрузки в I/O (операциях ввода-вывода).

# edac-poller
Ищет ошибки в памяти и устраняет их.

# devfreq_wq
Процесс  разрешает повторное использование так называемых “рабочих очередей” (workqueues).

# watchdogd
Средство наблюдения за нормальной работой системы, и если происходит какой-то сбой, то данный процесс запускает сброс (reset) системы с целью возобновить нормальное функционирование.

# kswapd0
Древняя, но почтенная система управления виртуальной памятью.

# kthrotld
Контролирует пропускную способность посредством “удушения” запросов в соответствии с приоритетами.

# ipv6_addrconf
Отвечает за конфигурацию очередей IPv6.

# kworker/u2:1-events_unbound
Тот же процесс, что и kworker.

# kstrp
Так называемый “парсер потоков”, он необходим для разбора и анализа сообщений на прикладном уровне.

# ata_sff
Процесс для использования устаревших ide/pata устройств.

# scsi_eh_0
Процесс обрабатывает ошибки, которые могут появляться при подключении дисков, определяемых как scsi-устройства.

# jbd2/vda1-8
Процесс, отвечающий за обновление журнала файловой системы.

# ttm_swap
Процесс, отвечающий за использование GPU памяти.

---

Source: [Курс "Базовое администрирование Linux-серверов"](https://slurm.io/linux-admin-base)
